
1.*****Function
 匿名函数:
 ****作用域和作用域链:
 *****闭包

匿名函数: 创建后，不被任何变量引用的函数
  只能用一次，不可重用
  何时使用: 如果一个函数，确定只使用一次
  优: 节约内存
  如何使用:
    1.自调: 函数定义完，立刻执行。
      划分临时作用域
    2.回调: 将函数定义后，传递给其它函数调用。

****作用域和作用域链:
 作用域(scope):一个变量的可用范围
 函数的生命周期: 
   1.程序开始执行时
     Execution Context Stack:
      执行环境栈: 专门按调用顺序保存每个函数的执行环境的集合。
      开始执行程序时，首先压入全局执行环境。
      创建window对象，保存所有全局函数和变量。其实window对象就是全局作用域对象。
   2.定义函数时
      创建函数对象，封装函数定义
      用函数名创建一个变量
      函数名变量引用函数对象

      在函数对象中添加scope属性:
        引用函数来自的作用域对象
        通常都引回window
   3.调用函数时
      创建活动对象(Actived Object):
        AO:保存函数调用时的局部变量
        其实AO对象就是函数作用域对象

        在AO中添加parent成员，引用函数来自的父级作用域对象
        由此形成作用域链。
        作用域链控制着变量的使用顺序: 
           优先使用局部的
           局部没有，才用全局的

      向ECS中压入本次函数调用的EC
      EC中的scope chain属性引用AO
   4.函数调用后:
      本次函数调用的EC出栈
      AO释放，局部变量一同释放

*****闭包: 		(函数作用域未被释放)
 即重用局部变量，又保护变量不受污染的机制
 为什么: 
   全局变量: 随处可用，可重复使用
         缺: 极易被污染
   局部变量: 不会被污染
         缺: 不可反复使用，只能在函数内使
用。
 何时使用: 如果希望一个变量可被反复使用，且不会被污染！
 闭包: 3步: 
   1. 用外层函数将变量和操作变量的函数包裹起来。
   2. 外层函数将内层函数对象返回
   3. 调用外层函数，获得内层函数对象

 鄙视中: 
   1. 先找受保护的变量，确定其值
      特殊: 变量的值很可能不是声明时的初始值――看外层函数调用结束时，n的值
   2. 找到操作变量的函数，确定如何操作
      特殊: 2种办法返回
       1. return fun
       2. 可能直接给全局变量赋值





