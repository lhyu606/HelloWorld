回顾: 
正则:
 1. 关键词的原文就是最简单的正则
 2. 字符集: [备选字符列表]
    [0-9] [A-Za-z]   [^47]
 3. 预定义字符集: \d  \w   \s   .
 4. 量词: 
   {m,n}  {m,}   {m}
   ?      +      *
 5. 选择和分组:
   规则1|规则2
   (多个规则)
 6. 指定匹配位置： 
   ^    $    \b

预判: 提前判断字符串是否满足部分规则
 密码强度:
   1. 至少包含一位大写字母
      如果不都由小写字母和数字组成
      (?![a-z0-9]+$)
      说明可能包含大写字母或标点
   2. 至少包含一位数字
      如果不都由字母组成
      (?![A-Za-z]+$)
      说明可能包含数字或标点
   3. 6~8位字母，数字的组合
      [0-9A-Za-z]{6,8}
^(?![a-z0-9]+$)(?![A-Za-z]+$)[0-9A-Za-z]{6,8}$
=====================================================================
1.***StringAPI:
  检索关键词:
  替换:
    延伸: 删除 格式化
  切割:

检索关键词: 
  1. 查找一个固定关键词的位置,可连续查找:
    var i=str.indexOf("关键词",fromi)
    var i=str.lastIndexOf("关键词",fromi)
   问题: 依次只能找一个固定的关键词，无法模糊查找。
  2. 判断字符串中是否包含符合规则的关键词
    var i=str.search(/reg/);
      如果i不是-1，说明包含。否则，不包含
    强调: 1. 不能连续查找   
          2. 正则本身区分大小写的
            如果忽略大小写: /reg/i
    问题: 1. 不能连续查找，永远找第一个
          2. 仅返回关键词位置，无法返回内容。
  3. 返回所有关键词的内容
    var kwords=str.match(/reg/i);
    查找str中和reg匹配的关键词内容。
    返回值: 保存所有关键词内容的数组
    ***如果找不到，返回null
        如果可能返回null，就必须先验证不是null，再操作。
    问题: 正则表达式，默认仅匹配第一个符合条件的关键词。不会匹配所有
    解决: /reg/ig
    缺: 无法获得每个关键词的位置。
  4. 即找每个关键词的位置，又找每个关键词的内容？

替换: 
  str=str.replace(/reg/ig,"替换值");
  将str中和reg匹配的敏感词替换为"替换值"
  强调: 不直接修改原字符串，而是返回新字符串。
  高级替换:
  str=str.replace(/reg/ig,
     function(kw,$1,$2,....){
	//kw 本次找到的关键词
	//$1 获得第1个分组()匹配的子内容
	//$2 ...
        return 替换值
     }
  )

 衍生:
  删除: 将找到的关键词替换为空字符串。
  格式化: 2步:
    1. 用正则将源字符串内容分组
    2. 在replace的替换值中，直接用$n代表第n个()的子内容。

切割: 将一个大的字符串，按指定字符分割为多个子字符串。
  var subs=str.split(/reg/);
  将str，按reg匹配的字符切割为多个子字符串，保存在数组subs中。
  强调: 在结果数组中，不包含分隔符
  





