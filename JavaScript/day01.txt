

正课:
1. 什么是JavaScript
2. 变量
3. 数据类型
4. 数据类型转换
5. 运算符和表达式

补:控制台:
  1. 多行编写: shift+enter
  2. 找回以前执行过的代码: ↑  ↓
  3. 清屏: 左上角圆形叉 clear
  4. 控制台可直接输出表达式的结果
  5. 字体大小: ctrl+鼠标滚轮
  6. 窗口大小: 右上角: Dock图标

4. 数据类型转换：
隐式转换: 程序根据自己的需要，自动转化数据的类型
强制转换: 由程序员主动调用函数执行的转换
 何时:当隐式转换的结果，不是想要的
 如何:
   1. x to string:2种:
     1. x.toString(): 不能转null和undefined
        原因: null和undefined表示什么都没有，无法加.调用函数。
     2. String(x): 万能！――首选
      模拟实现String(x)
      function String(x){
        if(x===undefined){
          return "undefined";
        }else if(x==null){
	  return "null";
        }else{
	  return x.toString();
        }
      }

  2.x to number:
    1. 非字符串内容转number:
      var num=Number(x)
      其实: Number也可转纯数字组成的字符串。
         bool-> true-1  false-0
      如果转不了,返回NaN：
       NaN: not a number
           NaN是number类型   
           NaN代表所有无效数字的值
    2. 字符串转number:
      parseInt(str)――取整，去小数
       原理：从str开头开始读取每个字符
             跳过开头的空字符
             碰到第一个非数字字符结束
         如果传入的参数不是字符串，则首先转为字符串，再读取内容。
         Number(true) vs parseInt(true)
             1           parseInt("true")
                             NaN
       问题:不认识小数点――去掉小数部分
      何时使用: 只有在非常确定的要去掉小数部分时。
      parseFloat(str) ―― 首选
       原理: 同parseInt
             认识第一个小数点
       自动判断转换后的类型，优先存为整数

     如果无法转为数字，返回NaN

  3. x to bool: Boolean(x)
     转换规则: 只有五个值会转为false:
               "" 0 NaN null undefined
           除此之外，都转为true

5. ***运算符和表达式: 
***程序:人的想法在计算机中的执行
运算符:程序中，模拟人的想法的符号
表达式:数据，变量，运算符组成的公式

算术运算: + - * / %
  何时使用%: 1. 判断能否整除
         2. 限制计算的结果不能超过最大值
  隐式转换:
    默认: 一切转为数字，再算术计算
      如果无法转为数字，则转为NaN:
        NaN参与任何算数计算，结果还是NaN 
    特殊: +运算中,碰到字符串，一切都转为字符串，+法计算变为字符串拼接

关系运算: 做比较，做判断
  > < >= <= == !=
  返回值: true/false
  隐式转换: 
   默认: 一切都转为数字,再比较
   特殊: 
     1.如果转不了，会转为NaN比较:
       NaN不大于，不小于，不等于任何值
       无法用普通的==判断是否是NaN
       解决: isNaN(num)
        判断num是不是NaN，结果true/false
        如果true,num是NaN
            false,num不是NaN，是数字
       反正用: !isNaN(num)
        判断num是不是数字
          true->是数字
          fales->不是数字
     2.undefined vs null
       问题: undefined==null -> true
            ==中undefined隐式转为null
       解决: 全等===
         不带隐式转换的==
         要求: 数据类型必须相同，其次再值相等。
       何时使用: 不希望比较时，自动隐士转换时――要求类型也必须相同时
         尤其: 在和undefined，null比较时
     3.如果参与比较的都是字符串:
       按位PK每个字符的unicode号
        如果前一位相同，就比下一位
        如果前几位都相同，比长度
     4.如果两个引用类型的对象做==比较
       比较的是对象的地址
       比如: []==[] -> false
         []表示创建一个新数组的意思
         有两个[]，就创建了两个新数组
         两个新数组的地址不可能一样

逻辑运算: 
  将多个关系运算，综合得出最终结论
  &&(而且)  ||(或)   !()
  如何使用:
  条件1&&条件2...:只有两个条件同时为true
                    结论才为true
                  只要一个条件为false
                    结论为false
  条件1||条件2...:只要一个条件为true
		    结论就为true
                  除非所有条件都为false
                    结论才是false
  !条件: 颠倒条件的判断结果

  隐式转换: 将每个条件临时转为boolean

***短路逻辑: 如果前一个条件已经可以得出最终的结论，则后续条件不再执行(即使写错)
***利用短路逻辑:
    1. 利用&&短路逻辑: 实现简单分支:
	一个条件，一件事，满足就做，不满足就不做。――只能简化if结构
       条件&&(操作)
       如果条件是true，才执行操作
       如果条件是false，不执行任何操作
    2. 利用||短路逻辑: 实现两个值自动选择有效的值使用。
        值1||值2:
        如果值1有效(只要不是5个值之一)
          就返回值1
        如果值1无效(值1是5个值之一)
          就返回值2

  课堂练习: 运算符优先级: 
    
位运算: 
  1. 左移和右移:
      m<<n  等于 m* 2的n次方
            m*Math.pow(2,n)
      m>>n  等于 m/ 2的n次方
  2. 取整:
      parseInt(m)
      m^0
      m|0
      m>>>0

扩展赋值运算: 对赋值运算的简写:
  m+=n   =>  m=m+n   累加
  m-=n   =>  m=m-n   
  m*=n   =>  m=m*n  
  m/=n   =>  m=m/n  
  m%=n   =>  m=m%n

  如果n是1: 递增1  递减1
  m+=1  =>  m++
  m-=1  =>  m--
   递增/递减单独使用，前++和后++完全等效
   如果递增/递减运算参与到其他表达式中:
     前++和后++的结果不同，会影响表达式:
***相同: 变量中的值一定都+1
***不同: 后++，返回旧值
         前++，返回新值

  练习: 
    var n=3;
    console.log(
	n++ + ++n + n++ 输出?
      //++n + n++ + ++n 输出？
    );
  












