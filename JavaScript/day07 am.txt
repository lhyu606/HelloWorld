
1. ***错误处理
2. *****Function
   创建
   重载
   匿名函数
   ****作用域和作用域链
   *****闭包

1. ***错误处理: 
  错误(bug): 程序执行过程中遇到的异常中断
    发生错误，程序会强行退出
  错误处理: 即使程序发生错误，也保证不会强行退出的一种机制
  如何处理: 
    try{
      可能出错的正常的语句
    }catch(err){
      只有出错才执行的错误处理代码
    }finally{
      无论是否出错，都必须执行的代码
    }
    其中: err在出错时，自动获得错误对象
      即使不使用，也不能省略！
     错误对象:在发生错误时，封装错误信息的对象。
  
      Error:6种:
       SyntaxError: 语法错误
       ReferenceError: 引用错误
       TypeError: 类型错误
       RangeError:范围错误
       URIError,EvalError:

    finally: 可省略

 问题:普通代码，放入try，执行效率会下降    所以，try中应该仅包含可能出错的代码
 解决:提前预知错误，使用if判断代替try结构

  关于try catch中的return
    finally中有return，会覆盖之前的所有return
    finally中没有return，程序会先确定之前return的返回值，但是，暂不返回。等待finally中的代码执行完，才返回。
      finally中的代码，不会影响之前确定的return结果。

  抛出自定义错误: throw new Error(“错误信息”)；
   何时需要抛出自定义错误?
     如果函数的定义者，希望提醒调用者错误的使用了函数时。



2.*****Function
 创建: 3种：
   1.声明: function 函数名(xxx){...}
    只有声明方式创建的函数，才会被提前
   2.函数直接量: 
    var 函数名=function(xxx){...}
    何时使用: 只要不希望声明提前时
   3.用new: 
    var 函数名=
      new Function(
	"参数","参数",...,
	"函数体")

 重载(overload):
  什么是: 相同函数名，不同参数列表的多个函数，在调用时，可自动根据传入参数的不同，执行不同的逻辑。
  何时使用: 如果一项任务，需要根据不同参数，选择不同的逻辑执行时。
  优点: 减轻调用者的负担。
  问题: js的语法不支持重载！
  解决: 使用arguments对象	（其内部自动创建，直接使用）
    什么是:专门接收调用时传入函数的所有参数值得类数组对象
      类数组对象: 长得像数组的对象-集合
         vs 数组: 
           相同: 1. 下标访问每个元素
               2. length属性表示元素个数
           不同: 1. 类型不同
                 2. 无法使用Array的API
     
  






