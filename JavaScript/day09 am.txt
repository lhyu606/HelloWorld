回顾: 
面向对象：
封装: 将一个事物的属性和功能集中定义在一个对象中。
优: 代码重用
缺: 不节约内存
 如何: 3种:
 1. 直接量: 
   var obj={
     属性名:值,
     方法名:function(){ this.属性名 }
   }
 2. 用new:
   var obj=new Object();
   obj.新属性=值;
   obj.新方法=function(){ this.属性名 }

 js中一切对象底层都是hash数组:
  vs hash数组: 
   相同: 用下标名称访问每个属性
         访问不存在的属性会返回undefined
         对不存在的属性赋值会自动创建
           ――js中的对象可随时添加新成员
         可用for in遍历每个属性
   不同: 类型不同！

 3. 反复创建多个相同结构(同一类型)的对象:
   2步:
   1. 定义构造函数，描述一类对象的同一结构:
    function 类型名/构造函数名(属性参数{
	this.属性名=属性参数
        this.方法名=function(){
	  this.属性名
        }
    }
   2. 用new调用构造函数――实例化一个对象
   var obj=new 类型名/构造函数名(属性值);
  
   new: 
    1. 创建新的空对象
    2. 设置新对象的__proto__继承构造函数的prototype。
    3. 用新对象调用构造函数
	将构造函数中所有this，临时替换为新的空对象。
        构造函数会向新对象中添加新成员
    4. 返回对象的地址保存到变量中。

继承: 父对象中的成员，子对象无需创建，即可直接使用！
优: 代码重用，节约内存
  js中的继承都是通过原型对象实现的
	――原型继承/继承原型
  原型对象: 集中保存同一类型的子对象共有成员的父级对象
  何时: 只要子对象中包含相同的成员，都要集中定义在原型对象中一份即可
  如何获得: 
    1. 构造函数.prototype
    2. 子对象.__proto__
        =>Object.getPrototypeOf(子对象)
  原型链: 由各级对象的__proto__逐级继承实现的链式结构。
    控制着对象成员的使用顺序。
  vs 作用域链:由函数调用时的作用域对象和全局作用域对象逐级引用形成的链式结构
    控制着变量的使用顺序。

自有属性和原型属性:
  自有属性: 直接保存在对象本地的属性
  原型属性: 保存在原型对象中，所有子对象共享的属性
  判断: 
    if(obj.hasOwnProperty("属性名"))
       是自有
    else if("属性名" in obj)     
       是共有
    else
       没有

判断对象的类型: 
  typeof(obj) 只能区分5种原始类型和对象，function，无法区分不同类型的对象。
  构造函数.prototype.isPrototypeOf(child)
  child instanceof 构造函数
  Object.prototype.toString.call(obj)
      [object class]

多态: 同一方法在不同情况下，表现出不同状态。
  为什么: 体现子对象与父对象之间的差异
  重写: 如果子对象觉得从父对象继承来的成员不好用，可在本地定义自有成员，覆盖父对象中的共有成员。

========================================================================
1. *****OOP
  修改继承:
2. ES5新特性

1. *****OOP
  修改继承:3种:
  1.每次只能修改一个对象的父对象
    child.__proto__=father
    =>Object.setPrototypeOf(child,father)
  2.批量修改所有子对象的父对象
    构造函数.prototype=father
    强调: 时机: 必须在开始创建对象之前就修改。
  3.两种类型间的继承: 最像Java的继承
   如果多个子类型，拥有相同的属性结构和共有方法。就要抽象出一个公共的父类型
    抽象: 每个具体的类型中相同的属性和方法集中定义到一个父类型中
    如何: 
     1. 定义公共父类型，集中定义子类型有用的属性和方法: 
     2. 让子类型的原型对象继承父类型的原型对象――子对象可使用公共父类型中的共有方法。――inherits
	Object.setPrototypeOf(
           子类型构造函数.prototype,
           父类型构造函数.prototype
	);
     3. 在子类型构造函数中借用父类型构造函数――extends
     父类型构造函数.call(this,属性参数)
     父类型构造函数.apply(this,arguments)

鄙视题: call vs apply
    相同: 都是强行调用函数，并替换函数中的this为指定对象。
    不同: 参数: 
      call，每个参数独立传入
      apply，所有参数必须放在一个集合中统一传入

inherits继承: 直接使用父对象中的成员
extends扩展: 为子对象扩展父类型没有的属性






